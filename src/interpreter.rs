use token::{Token, Kind, Tokenizer};
use ast::Node;
use parser::Parser;
use std::collections::HashMap;

// # Interpreter
//
// Represents the interpreter that is responsible for interpret 
// the Abstracted Sintax Tree generated by the Parser

pub struct Interpreter {
    pub symbol_table: HashMap<String, String>
}
impl Interpreter {
    pub fn new() -> Self {
        Interpreter {
            symbol_table: HashMap::new()
        }
    }
    // eval_tree
    //
    // It visits each node evaluating the binary operations returning the
    // result as String
    //
    // Example:
    //   The expression 3 * 5 + 5 will produce the follow tree and the result 20.
    //   It evaluates the left side first and applies a post-order calc
    //
    //         +-+
    //         |-|
    //     +---------+
    //     |         |
    //     v         v
    //    +-+       +-+
    //    |*|       |5|
    //  +-----+     +-+
    //  |     |
    //  v     v
    // ---   ---
    // |3|   |5|
    // +-+   +-+
    pub fn eval_tree(&mut self, tree: Node) -> String {
        let nodes = tree.clone().nodes();
        let kind = tree.clone().kind();
        match nodes {
            (Some(lnode), Some(rnode)) => match kind {
                Kind::Operator =>
                    binary_operation(self.eval_tree(lnode),
                                     &tree.value(),
                                     self.eval_tree(rnode)),

                Kind::Comparison =>
                    binary_comparison(self.eval_tree(lnode),
                                      &tree.value(),
                                      self.eval_tree(rnode)),

                Kind::Assign => {
                    let value = self.eval_tree(rnode);
                    self.assign_variable(lnode.value(), value)
                },

                _ => panic!("Interpreter error: unexpecte node kind {:?}",
                                tree)
            },

            (Some(lnode), None) => self.eval_tree(lnode),

            (None, Some(rnode)) => match tree.clone().kind() {
                Kind::Operator =>
                    unary_operation(tree.value(), self.eval_tree(rnode)),

                Kind::Return => self.eval_tree(rnode),

                _ => String::new()
            },

            (None, None) => match kind {
                Kind::Statement => {
                    return tree.clone().statements
                        .unwrap()
                        .iter()
                        .map(|n| self.eval_tree(n.clone()))
                        .fold(String::new(), |_, s|{
                            s
                        })
                },

                Kind::Conditional=> {
                    let mut condition = self.eval_tree(tree.clone().conditional.unwrap());
                    let equals = String::from("==");
                    let truly = String::from("true");

                    while binary_comparison(condition.clone(), &equals, truly.clone()) == "true" {
                        let _ = tree.clone().statements
                            .unwrap()
                            .iter()
                            .map(|n| self.eval_tree(n.clone()))
                            .fold(String::new(), |_, s|{
                                s
                            });
                        condition = self.eval_tree(tree.clone().conditional.unwrap());
                    }

                    return String::new()
                },

                Kind::ID => self.symbol_table[&tree.value()].clone(),

                _ => tree.value()
            }
        }
    }

    fn assign_variable(&mut self, name: String, value: String) -> String {
        self.symbol_table.insert(name, value.clone());
        value
    }
}

// unary_operation
// Resolves the unary operations Example: --1 == 1, 1++-1==0
fn unary_operation(operator: String, operand: String) -> String {
    let ioperand = if let Ok(val) = operand.parse::<i32>() { val } else {
        panic!("Sintax error: invalid unary operand {}", operand)
    };
    let result = match operator.as_ref() {
        "+" => ioperand,
        "-" => -(ioperand),
        _ => panic!("Sintax error: invalid unary operator {}", operator)
    };

    result.to_string()
}

// binary_operation
// Resolve binary expression for the given left, operator and right operand
fn binary_operation(left: String, operator: &String, right: String) -> String {
    let operleft = if let Ok(val) = left.parse::<i32>() { val } else {
        panic!("Sintax error: invalid operand: {}", left)
    };
    let operright = if let Ok(val) = right.parse::<i32>() { val } else {
        panic!("Sintax error: invalid operand: {}", right)
    };
    let result = match operator.as_ref() {
        "+" => operleft + operright,
        "-" => operleft - operright,
        "*" => operleft * operright,
        "/" => operleft / operright,
        _ => panic!("Sintax error: invalid operator {}", operator)
    };

    result.to_string()
}

// binary_operation
// Resolve binary expression for the given left, operator and right operand
fn binary_comparison(left: String, operator: &String, right: String) -> String {
    let bleft = left.replace("true","1").replace("false","0");
    let bright = right.replace("true","1").replace("false","0");

    let operleft = if let Ok(val) = bleft.parse::<i32>() { val } else {
        panic!("Sintax error: invalid operand: {}", left)
    };
    let operright = if let Ok(val) = bright.parse::<i32>() { val } else {
        panic!("Sintax error: invalid operand: {}", right)
    };

    let result = match operator.as_ref() {
        "==" => operleft == operright,
        "!=" => operleft != operright,
        "<" => operleft < operright,
        ">" => operleft > operright,
        "or"|"||" => operleft == 1 || operright == 1,
        "and"|"&&" => operleft == 1 && operright == 1,
        _ => panic!("Sintax error: invalid operator {}", operator)
    };

    result.to_string()
}

#[test]
fn it_eval_tree_leaf() {
    let token = Token::build(Kind::Integer, String::from("10"));
    let leaf = Node::leaf(token);

    assert_eq!("10", Interpreter::new().eval_tree(leaf))
}

#[test]
fn it_eval_the_node_binary_operation() {
    // 3+5
    let left = Node::leaf(Token::build(Kind::Integer, String::from("3")));
    let operator = Token::build(Kind::Operator, String::from("+"));
    let right = Node::leaf(Token::build(Kind::Integer, String::from("5")));
    let node = Node::new(left, operator, right);

    assert_eq!("8", Interpreter::new().eval_tree(node))
}

#[test]
fn it_eval_complex_tree() {
    // 5+5*3
    let left = Node::leaf(Token::build(Kind::Integer, String::from("3")));
    let operator = Token::build(Kind::Operator, String::from("*"));
    let right = Node::leaf(Token::build(Kind::Integer, String::from("5")));
    let plusnode = Node::new(left, operator, right);

    let operator = Token::build(Kind::Operator, String::from("+"));
    let sumright = Node::leaf(Token::build(Kind::Integer, String::from("5")));
    let sumnode = Node::new(plusnode, operator, sumright);

    assert_eq!("20", Interpreter::new().eval_tree(sumnode))
}

#[test]
fn it_eval_unary_operations() {
    // 2 -- 2
    let rnode = Node::leaf(Token::build(Kind::Integer, String::from("2")));
    let negative_op = Token::build(Kind::Operator, String::from("-"));
    let unarynode = Node::unary(negative_op, rnode);

    let operator = Token::build(Kind::Operator, String::from("-"));
    let left = Node::leaf(Token::build(Kind::Integer, String::from("2")));
    let sumnode = Node::new(left, operator, unarynode);

    assert_eq!("4", Interpreter::new().eval_tree(sumnode))
}

#[test]
fn it_sums() {
    let text = "5+1";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("6", Interpreter::new().eval_tree(parser.parse()));
}

#[test]
fn it_substract() {
    let text = "5-1";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("4", Interpreter::new().eval_tree(parser.parse()));
}

#[test]
fn it_multiplies() {
    let text = "5*2";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("10", Interpreter::new().eval_tree(parser.parse()));
}

#[test]
fn it_divide() {
    let text = "4/2";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("2", Interpreter::new().eval_tree(parser.parse()));
}

#[test]
fn it_accepts_multiples_operation() {
    let text = "10+5-4-1";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("10", Interpreter::new().eval_tree(parser.parse()));
}

#[test]
fn it_respect_precedence() {
    let text = "1+1*2";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("3", Interpreter::new().eval_tree(parser.parse()));
}

#[test]
fn it_respects_grouped_expression() {
    let text = "4+(1+(1+1)*2)+1";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("10", Interpreter::new().eval_tree(parser.parse()));
}

#[test]
fn it_accept_unary_operations() {
    let text = "(4+-1)--2";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("5", Interpreter::new().eval_tree(parser.parse()));
}

#[test]
fn it_accept_binary_comparison() {
    let text = "4 == 2";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("false", Interpreter::new().eval_tree(parser.parse()));
}

#[test]
fn it_accept_composed_binary_comparison() {
    let text = "2 == 2 and 3 != 3";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("false", Interpreter::new().eval_tree(parser.parse()));
}


#[test]
fn it_eval_block_assigning_vars_to_symbol_table() {
    let text = "begin x = 10 end";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new();
    let _ = interpreter.eval_tree(parser.parse());

    assert_eq!("10", interpreter.symbol_table["x"]);
}

#[test]
fn it_eval_block_retrieve_vars_from_symbol_table() {
    let text = "begin x = 10; y = x + 5 end";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new();
    let result = interpreter.eval_tree(parser.parse());

    assert_eq!("15", interpreter.symbol_table["y"]);
}

#[test]
fn it_eval_block_retrieve_eturn_statement() {
    let text = "begin x = 10; y = x + 5; return y + 5 end";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new();
    let result = interpreter.eval_tree(parser.parse());

    assert_eq!("20", result);
}

#[test]
fn it_eval_block_bolean_block() {
    let text = "begin x = 1; y = 2; return y == x end";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new();
    let result = interpreter.eval_tree(parser.parse());

    assert_eq!("false", result);
}

#[test]
fn it_eval_while_blocks() {
    let text = "begin  y = 0; while y != 4 begin y = y + 1 end; return y == 0 end";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new();
    let result = interpreter.eval_tree(parser.parse());

    assert_eq!("false", result);
}
