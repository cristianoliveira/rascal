use ast::{Node, Operation};
use primitive::Type;
use frame::{Frame, FrameStack};

// # Interpreter
//
// Represents the interpreter that is responsible for interpret
// the Abstracted Sintax Tree generated by the Parser

pub struct Interpreter {
    pub stack: FrameStack,
}
impl Interpreter {
    pub fn new() -> Self {
        Interpreter {
            stack: FrameStack::new()
        }
    }

    fn scope(&mut self) -> &mut Frame {
        self.stack.current()
    }

    // eval_tree
    //
    // It visits each node evaluating the binary operations returning the
    // result as String
    //
    // Example:
    //   The expression 3 * 5 + 5 will produce the follow tree and the result 20.
    //   It evaluates the left side first and applies a post-order calc
    //
    //         +-+
    //         |-|
    //     +---------+
    //     |         |
    //     v         v
    //    +-+       +-+
    //    |*|       |5|
    //  +-----+     +-+
    //  |     |
    //  v     v
    // ---   ---
    // |3|   |5|
    // +-+   +-+
    pub fn eval(&mut self, tree: Node) -> String {
        match self.eval_tree(tree) {
            Ok(result) => result.to_string(),
            Err(error) => error
        }
    }

    pub fn eval_tree(&mut self, tree: Node) -> Result<Type, String> {
        let Node{operation, ..} = tree;
        match *operation.clone() {
            Operation::Main(statements) => {
                let mut last_stm_return = Ok(Type::Nil);
                for statement in statements {
                    last_stm_return = self.eval_tree(statement);

                    if last_stm_return.is_err() {
                        break
                    }
                }
                last_stm_return
            },

            Operation::IfElse(conditional, lnode, rnode) => {
                let condition = try!(self.eval_tree(conditional));

                if truthy(condition) {
                    self.eval_tree(lnode)
                } else {
                    self.eval_tree(rnode)
                }
            },

            Operation::Binary(lnode, operator, rnode) => {
                binary_operation(
                    try!(self.eval_tree(lnode)),
                    operator,
                    try!(self.eval_tree(rnode))
                )
            },

            Operation::Comparison(lnode, operator, rnode) =>
                binary_comparison(
                    try!(self.eval_tree(lnode)),
                    operator,
                    try!(self.eval_tree(rnode))
                ),

            Operation::CallFunc(nodename, params) => {
                let func_frame = self.scope().clone();
                self.stack.push(func_frame);

                let name = nodename.value;
                // println!("calling {}", name);
                if let Some(Type::Func(fparams, block)) = self.scope().get(&*name).clone() {
                    for (pname, pvalue) in fparams.iter().zip(params.iter()) {
                        let value = try!(self.eval_tree(pvalue.clone()));
                        self.scope().locals.insert(pname.clone().value, value);
                    }

                    self.eval_tree(block)
                } else {
                    return Err(format!("Value error: {} is not callable", name))
                }
            },

            Operation::DefineFunc(lnode, func) => {
                let name = lnode.value;
                if self.scope().has(&*name) {
                    return Err(format!("Value error: variable {} has already defined.", name))
                }

                self.scope().ilocals.insert(name, func);
                Ok(Type::Nil)
            },

            Operation::DefineImut(lnode, rnode) => {
                let name = lnode.value;
                let value = try!(self.eval_tree(rnode));

                if self.scope().has(&*name) {
                    return Err(format!("Value error: variable {} has already defined.", name))
                }

                self.scope().ilocals.insert(name, value.clone());
                Ok(Type::Nil)
            },

            Operation::DefineVar(lnode, rnode) => {
                let name = lnode.value;

                if self.scope().has(&*name) {
                    return Err(format!("Value error: variable {} has already defined.", name))
                }

                let value = try!(self.eval_tree(rnode));

                self.scope().locals.insert(name, value.clone());
                Ok(value)
            },

            Operation::ReAssign(lnode, rnode) => {
                let name = lnode.value;

                if !self.scope().has(&*name) {
                    return Err(format!("Value error: variable {} used before declared.", name))
                }

                if self.scope().is_imutable(&*name) {
                    return Err(format!("Value error: imutable {} was reassigned.", name))
                }

                let value = try!(self.eval_tree(rnode));

                self.scope().locals.insert(name, value.clone());
                Ok(value)
            },

            Operation::NegUnary(node) => {
                unary_operation("-", try!(self.eval_tree(node)))
            },

            Operation::Return(node) => self.eval_tree(node),

            Operation::Print(node) => {
                let result = try!(self.eval_tree(node));
                println!("{}", result.to_string());
                Ok(Type::Nil)
            },

            Operation::Block(statements) => {
                let copy_scope = self.scope().clone();
                self.stack.push(copy_scope);
                let mut last_stm_return = Ok(Type::Nil);
                for stm in statements {
                    last_stm_return = self.eval_tree(stm.clone());

                    if last_stm_return.is_err() {
                        break
                    }
                }
                self.stack.pop();
                last_stm_return
            },

            Operation::Loop(conditional, block) => {
                let mut condition = try!(self.eval_tree(conditional.clone()));

                while truthy(condition) {
                    let _ = try!(self.eval_tree(block.clone()));
                    condition = try!(self.eval_tree(conditional.clone()));
                }

                Ok(Type::Nil)
            },

            Operation::Identifier(name) => {
                if let Some(value) = self.scope().get(&*name) {
                    Ok(value)
                } else {
                    Err(format!("Variable {} doesn't exist in this context", name))
                }
            },

            Operation::Constant(var) => Ok(var),

            _ => Ok(Type::Nil)
        }
    }
}

// unary_operation
// Resolves the unary operations Example: --1 == 1, 1++-1==0
fn unary_operation(operator: &str, operand: Type) -> Result<Type, String> {
    match (operator , operand.clone()) {
        ("+", Type::Int(val)) => Ok(Type::Int(val)),
        ("-", Type::Int(val)) => Ok(Type::Int(-val)),
        _ => Err(format!("Operation error: invalid operation {:?}{:?}",
                    operator, operand))
    }
}

// binary_operation
// Resolve binary expression for the given left, operator and right operand
fn binary_operation(left: Type, operator: String, right: Type) -> Result<Type, String> {
    match (left, operator.as_ref(), right) {
        (r, "*", l) => Ok(r * l),
        (r, "/", l) => Ok(r / l),
        (r, "+", l) => Ok(r + l),
        (r, "-", l) => Ok(r - l),
        (r, "%", l) => Ok(r % l),
        _ => Err(format!("Sintax error: invalid operator {:?}", operator))
    }
}

// binary_operation
// Resolve binary expression for the given left, operator and right operand
fn binary_comparison(left: Type, operator: String, right: Type) -> Result<Type, String> {
    match operator.as_ref() {
        "==" => Ok(Type::Bool(left == right)),
        "!=" => Ok(Type::Bool(left != right)),
        ">"  => Ok(Type::Bool(left >  right)),
        "<"  => Ok(Type::Bool(left <  right)),
        "||"|"or"  => Ok(Type::Bool(right.as_bool() || left.as_bool())),
        "&&"|"and" => Ok(Type::Bool(right.as_bool() && left.as_bool())),
        _ =>
            Err(format!("Sintax error: invalid operation {:?}{:?}{:?}",
                        right, operator, left))
    }
}

fn truthy(condition: Type) -> bool {
    binary_comparison(condition, String::from("=="), Type::Bool(true)).unwrap().as_bool()
}


#[cfg(test)]
mod test {

    use token::{Token, Kind, Tokenizer};
    use interpreter::Interpreter;
    use parser::Parser;
    use ast::Node;

    #[test]
    fn it_eval_tree_leaf() {
        let token = Token::build(Kind::Integer, String::from("10"));
        let leaf = Node::constant(token);

        assert_eq!("10", Interpreter::new().eval(leaf))
    }

    #[test]
    fn it_eval_the_node_binary_operation() {
        // 3+5
        let left = Node::constant(Token::build(Kind::Integer, String::from("3")));
        let operator = Token::build(Kind::Operator, String::from("+"));
        let right = Node::constant(Token::build(Kind::Integer, String::from("5")));
        let node = Node::binary(left, operator.value, right);

        assert_eq!("8", Interpreter::new().eval(node))
    }

    #[test]
    fn it_eval_complex_tree() {
        // 5+5*3
        let left = Node::constant(Token::build(Kind::Integer, String::from("3")));
        let operator = Token::build(Kind::Operator, String::from("*"));
        let right = Node::constant(Token::build(Kind::Integer, String::from("5")));
        let plusnode = Node::binary(left, operator.value, right);

        let operator = Token::build(Kind::Operator, String::from("+"));
        let sumright = Node::constant(Token::build(Kind::Integer, String::from("5")));
        let sumnode = Node::binary(plusnode, operator.value, sumright);

        assert_eq!("20", Interpreter::new().eval(sumnode))
    }

    #[test]
    fn it_eval_unary_operations() {
        // 2 -- 2
        let rnode = Node::constant(Token::build(Kind::Integer, String::from("2")));
        let negative_op = Token::build(Kind::Operator, String::from("-"));
        let unarynode = Node::unary(negative_op, rnode);

        let operator = Token::build(Kind::Operator, String::from("-"));
        let left = Node::constant(Token::build(Kind::Integer, String::from("2")));
        let sumnode = Node::binary(left, operator.value, unarynode);

        assert_eq!("4", Interpreter::new().eval(sumnode))
    }

    #[test]
    fn it_sums() {
        let text = "5+1";
        let tokenizer = Tokenizer::new(String::from(text));
        let mut parser = Parser::new(tokenizer);

        assert_eq!("6", Interpreter::new().eval(parser.parse()));
    }

    #[test]
    fn it_substract() {
        let text = "5-1";
        let tokenizer = Tokenizer::new(String::from(text));
        let mut parser = Parser::new(tokenizer);

        assert_eq!("4", Interpreter::new().eval(parser.parse()));
    }

    #[test]
    fn it_multiplies() {
        let text = "5*2";
        let tokenizer = Tokenizer::new(String::from(text));
        let mut parser = Parser::new(tokenizer);

        assert_eq!("10", Interpreter::new().eval(parser.parse()));
    }

    #[test]
    fn it_divide() {
        let text = "4/2";
        let tokenizer = Tokenizer::new(String::from(text));
        let mut parser = Parser::new(tokenizer);

        assert_eq!("2", Interpreter::new().eval(parser.parse()));
    }

    #[test]
    fn it_mod() {
        let text = "4%2";
        let tokenizer = Tokenizer::new(String::from(text));
        let mut parser = Parser::new(tokenizer);

        assert_eq!("0", Interpreter::new().eval(parser.parse()));
    }

    #[test]
    fn it_accepts_multiples_operation() {
        let text = "10+5-4-1";
        let tokenizer = Tokenizer::new(String::from(text));
        let mut parser = Parser::new(tokenizer);

        assert_eq!("10", Interpreter::new().eval(parser.parse()));
    }

    #[test]
    fn it_respect_precedence() {
        let text = "1+1*2";
        let tokenizer = Tokenizer::new(String::from(text));
        let mut parser = Parser::new(tokenizer);

        assert_eq!("3", Interpreter::new().eval(parser.parse()));
    }

    #[test]
    fn it_respects_grouped_expression() {
        let text = "4+(1+(1+1)*2)+1";
        let tokenizer = Tokenizer::new(String::from(text));
        let mut parser = Parser::new(tokenizer);

        assert_eq!("10", Interpreter::new().eval(parser.parse()));
    }

    #[test]
    fn it_accept_unary_operations() {
        let text = "(4+-1)--2";
        let tokenizer = Tokenizer::new(String::from(text));
        let mut parser = Parser::new(tokenizer);

        assert_eq!("5", Interpreter::new().eval(parser.parse()));
    }

    #[test]
    fn it_accept_binary_comparison() {
        let text = "4 == 2";
        let tokenizer = Tokenizer::new(String::from(text));
        let mut parser = Parser::new(tokenizer);

        assert_eq!("false", Interpreter::new().eval(parser.parse()));
    }

    #[test]
    fn it_accept_lesser_than_comparison() {
        let text = "6 < 10";
        let tokenizer = Tokenizer::new(String::from(text));
        let mut parser = Parser::new(tokenizer);

        assert_eq!("true", Interpreter::new().eval(parser.parse()));
    }

    #[test]
    fn it_accept_composed_binary_comparison() {
        let text = "1 > 1 or 2 == 2 and 3 != 3";
        let tokenizer = Tokenizer::new(String::from(text));
        let mut parser = Parser::new(tokenizer);

        assert_eq!("false", Interpreter::new().eval(parser.parse()));
    }


    #[test]
    fn it_eval_block_assigning_vars_to_symbol_table() {
        let text = "begin let mut x = 10; return x end";
        let tokenizer = Tokenizer::new(String::from(text));
        let mut parser = Parser::new(tokenizer);
        let mut interpreter = Interpreter::new();
        let result = interpreter.eval(parser.parse());
        assert_eq!("10", result);
    }

    #[test]
    fn it_eval_block_retrieve_vars_from_symbol_table() {
        let text = "begin let x = 10; let mut y = x + 5; return y end";
        let tokenizer = Tokenizer::new(String::from(text));
        let mut parser = Parser::new(tokenizer);
        let mut interpreter = Interpreter::new();
        let result = interpreter.eval(parser.parse());

        assert_eq!("15", result);
    }

    #[test]
    fn it_eval_functions_without_params() {
        let text = "{ fn two = [] { return 2 }; two() }";
        let tokenizer = Tokenizer::new(String::from(text));
        let mut parser = Parser::new(tokenizer);
        let mut interpreter = Interpreter::new();
        let result = interpreter.eval(parser.parse());

        assert_eq!("2", result);
    }

    #[test]
    fn it_eval_functions_with_params() {
        let text = "{ fn add = [x] { return x + 2 }; add(2) }";
        let tokenizer = Tokenizer::new(String::from(text));
        let mut parser = Parser::new(tokenizer);
        let mut interpreter = Interpreter::new();
        let result = interpreter.eval(parser.parse());

        assert_eq!("4", result);
    }

    #[test]
    fn it_eval_functions_with_multiple_params() {
        let text = "{ fn add = [x,y,z] { return x + y + z }; add(2,1,2) }";
        let tokenizer = Tokenizer::new(String::from(text));
        let mut parser = Parser::new(tokenizer);
        let mut interpreter = Interpreter::new();
        let result = interpreter.eval(parser.parse());

        assert_eq!("5", result);
    }

}
