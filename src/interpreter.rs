use token::{Token, Kind, Tokenizer};
use ast::Node;
use parser::Parser;
use std::collections::HashMap;

// # Interpreter
//
// Represents the interpreter that is responsible for interpret 
// the Abstracted Sintax Tree generated by the Parser

pub struct Interpreter {
    pub symbol_table: HashMap<String, Token>,
    pub imutable_table: HashMap<String, Token>
}
impl Interpreter {
    pub fn new() -> Self {
        Interpreter {
            symbol_table: HashMap::new(),
            imutable_table: HashMap::new()
        }
    }
    // eval_tree
    //
    // It visits each node evaluating the binary operations returning the
    // result as String
    //
    // Example:
    //   The expression 3 * 5 + 5 will produce the follow tree and the result 20.
    //   It evaluates the left side first and applies a post-order calc
    //
    //         +-+
    //         |-|
    //     +---------+
    //     |         |
    //     v         v
    //    +-+       +-+
    //    |*|       |5|
    //  +-----+     +-+
    //  |     |
    //  v     v
    // ---   ---
    // |3|   |5|
    // +-+   +-+
    pub fn eval(&mut self, tree: Node) -> String {
        self.eval_tree(tree).value
    }

    pub fn eval_tree(&mut self, tree: Node) -> Token {
        let Node{ token, statements, conditional, left, right } = tree;
        match (token.kind.clone(), *left, *right, *conditional) {

            (Kind::Conditional, Some(lnode), Some(rnode), Some(conditional)) => {
                let condition = self.eval_tree(conditional);

                if truthy(condition) {
                    self.eval_tree(lnode)
                } else {
                    self.eval_tree(rnode)
                }
            },

            (Kind::Operator, Some(lnode), Some(rnode), None) => {
                binary_operation(
                    self.eval_tree(lnode), &token, self.eval_tree(rnode)
                )
            },

            (Kind::Comparison, Some(lnode), Some(rnode), None) =>
                    binary_comparison(
                        self.eval_tree(lnode), &token, self.eval_tree(rnode)
                    ),

            (Kind::Assign, Some(lnode), Some(rnode), None) => {
                let value = self.eval_tree(rnode);
                let Token{ kind, value: name } = lnode.token;

                if kind == Kind::CONST {
                    self.imutable_table.insert(name, value.clone());
                } else {
                    self.symbol_table.insert(name, value.clone());
                }
                value
            },

            (Kind::ReAssign, Some(lnode), Some(rnode), None) => {
                let value = self.eval_tree(rnode);
                let Token{ value: name, ..} = lnode.token;

                if self.imutable_table.contains_key(&*name) {
                    panic!("Value error: invalid assign imutable var: {}", name)
                }

                if !self.symbol_table.contains_key(&*name) {
                    panic!("Value error: used before declared var: {}", name)
                }

                self.symbol_table.insert(name, value.clone());
                value
            },


            (Kind::Operator, None, Some(rnode), None) =>
                unary_operation(token, self.eval_tree(rnode)),

            (Kind::Return, None, Some(rnode), None) => self.eval_tree(rnode),

            (Kind::Statement, None, None, None) => {
                if statements.is_some() {
                    statements.unwrap().iter()
                        .map(|n| self.eval_tree(n.clone()))
                        .fold(token, |_, t| t)
                } else {
                    Token::build(Kind::End, String::from("nil"))
                }
            },

            (Kind::Conditional, None, None, conditional) => {
                let mut condition = self.eval_tree(conditional.clone().unwrap());

                while truthy(condition) {
                    let _ = statements.clone()
                        .unwrap()
                        .iter()
                        .map(|n| self.eval_tree(n.clone()))
                        .fold(token.clone(), |_, t| t);
                    condition = self.eval_tree(conditional.clone().unwrap());
                }

                return Token::build(Kind::Empty, String::from("nil"))
            },

            (Kind::ID, None, None, None) =>
                match self.imutable_table.get(&token.value) {
                    Some(value) => return value.clone(),
                    None =>
                        match self.symbol_table.get(&token.value) {
                            Some(value) => return value.clone(),
                            None =>
                                panic!("Interpreter error: undeclared variable")
                        }
                },

            (_, Some(lnode), None, None) => self.eval_tree(lnode),
            (_, None, Some(rnode), None) => self.eval_tree(rnode),
            _ => token
        }
    }
}

// unary_operation
// Resolves the unary operations Example: --1 == 1, 1++-1==0
fn unary_operation(operator: Token, operand: Token) -> Token {
    let ioperand = if let Ok(val) = operand.value.parse::<i32>() { val } else {
        panic!("Sintax error: invalid unary operand {:?}", operand)
    };
    let result = match operator.value.as_ref() {
        "+" => ioperand,
        "-" => -(ioperand),
        _ => panic!("Sintax error: invalid unary operator {:?}", operator)
    };

    Token::build(operand.kind, result.to_string())
}

// binary_operation
// Resolve binary expression for the given left, operator and right operand
fn binary_operation(left: Token, operator: &Token, right: Token) -> Token {
    let operleft = if let Ok(val) = left.value.parse::<i32>() { val } else {
        panic!("Sintax error: invalid operand: {:?}", left)
    };
    let operright = if let Ok(val) = right.value.parse::<i32>() { val } else {
        panic!("Sintax error: invalid operand: {:?}", right)
    };
    let result = match operator.value.as_ref() {
        "+" => operleft + operright,
        "-" => operleft - operright,
        "*" => operleft * operright,
        "/" => operleft / operright,
        _ => panic!("Sintax error: invalid operator {:?}", operator)
    };

    Token::build(left.kind, result.to_string())
}

// binary_operation
// Resolve binary expression for the given left, operator and right operand
fn binary_comparison(left: Token, operator: &Token, right: Token) -> Token {
    let bleft = left.value.replace("true","1").replace("false","0");
    let bright = right.value.replace("true","1").replace("false","0");

    let operleft = if let Ok(val) = bleft.parse::<i32>() { val } else {
        panic!("Sintax error: invalid operand: {:?}", left)
    };
    let operright = if let Ok(val) = bright.parse::<i32>() { val } else {
        panic!("Sintax error: invalid operand: {:?}", right)
    };

    let result = match operator.value.as_ref() {
        "==" => operleft == operright,
        "!=" => operleft != operright,
        "<" => operleft < operright,
        ">" => operleft > operright,
        "or"|"||" => operleft == 1 || operright == 1,
        "and"|"&&" => operleft == 1 && operright == 1,
        _ => panic!("Sintax error: invalid operator {:?}", operator)
    };

    Token::build(left.kind, result.to_string())
}

fn truthy(condition: Token) -> bool {
    binary_comparison(
        condition,
        &Token::build(Kind::Comparison, String::from("==")),
        Token::build(Kind::Comparison, String::from("true"))).value == "true"
}

#[test]
fn it_eval_tree_leaf() {
    let token = Token::build(Kind::Integer, String::from("10"));
    let leaf = Node::leaf(token);

    assert_eq!("10", Interpreter::new().eval(leaf))
}

#[test]
fn it_eval_the_node_binary_operation() {
    // 3+5
    let left = Node::leaf(Token::build(Kind::Integer, String::from("3")));
    let operator = Token::build(Kind::Operator, String::from("+"));
    let right = Node::leaf(Token::build(Kind::Integer, String::from("5")));
    let node = Node::binary(left, operator, right);

    assert_eq!("8", Interpreter::new().eval(node))
}

#[test]
fn it_eval_complex_tree() {
    // 5+5*3
    let left = Node::leaf(Token::build(Kind::Integer, String::from("3")));
    let operator = Token::build(Kind::Operator, String::from("*"));
    let right = Node::leaf(Token::build(Kind::Integer, String::from("5")));
    let plusnode = Node::binary(left, operator, right);

    let operator = Token::build(Kind::Operator, String::from("+"));
    let sumright = Node::leaf(Token::build(Kind::Integer, String::from("5")));
    let sumnode = Node::binary(plusnode, operator, sumright);

    assert_eq!("20", Interpreter::new().eval(sumnode))
}

#[test]
fn it_eval_unary_operations() {
    // 2 -- 2
    let rnode = Node::leaf(Token::build(Kind::Integer, String::from("2")));
    let negative_op = Token::build(Kind::Operator, String::from("-"));
    let unarynode = Node::unary(negative_op, rnode);

    let operator = Token::build(Kind::Operator, String::from("-"));
    let left = Node::leaf(Token::build(Kind::Integer, String::from("2")));
    let sumnode = Node::binary(left, operator, unarynode);

    assert_eq!("4", Interpreter::new().eval(sumnode))
}

#[test]
fn it_sums() {
    let text = "5+1";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("6", Interpreter::new().eval(parser.parse()));
}

#[test]
fn it_substract() {
    let text = "5-1";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("4", Interpreter::new().eval(parser.parse()));
}

#[test]
fn it_multiplies() {
    let text = "5*2";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("10", Interpreter::new().eval(parser.parse()));
}

#[test]
fn it_divide() {
    let text = "4/2";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("2", Interpreter::new().eval(parser.parse()));
}

#[test]
fn it_accepts_multiples_operation() {
    let text = "10+5-4-1";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("10", Interpreter::new().eval(parser.parse()));
}

#[test]
fn it_respect_precedence() {
    let text = "1+1*2";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("3", Interpreter::new().eval(parser.parse()));
}

#[test]
fn it_respects_grouped_expression() {
    let text = "4+(1+(1+1)*2)+1";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("10", Interpreter::new().eval(parser.parse()));
}

#[test]
fn it_accept_unary_operations() {
    let text = "(4+-1)--2";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("5", Interpreter::new().eval(parser.parse()));
}

#[test]
fn it_accept_binary_comparison() {
    let text = "4 == 2";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("false", Interpreter::new().eval(parser.parse()));
}

#[test]
fn it_accept_composed_binary_comparison() {
    let text = "1 > 1 or 2 == 2 and 3 != 3";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("false", Interpreter::new().eval(parser.parse()));
}


#[test]
fn it_eval_block_assigning_vars_to_symbol_table() {
    let text = "begin mut x = 10 end";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new();
    let _ = interpreter.eval(parser.parse());

    assert_eq!("10", interpreter.symbol_table["x"].value);
}

#[test]
fn it_eval_block_retrieve_vars_from_symbol_table() {
    let text = "begin imut x = 10; mut y = x + 5 end";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new();
    let _ = interpreter.eval(parser.parse());

    assert_eq!("10", interpreter.imutable_table["x"].value);
    assert_eq!("15", interpreter.symbol_table["y"].value);
}

