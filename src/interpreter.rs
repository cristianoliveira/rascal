use token;
use ast;
use parser::Parser;

// # Interpreter
//
// Represents the interpreter that is responsible for interpret 
// the Abstracted Sintax Tree generated by the Parser
pub struct Interpreter {
    parser: Parser,
}

impl Interpreter {
    pub fn new(parser: Parser) -> Self {
        Interpreter {
            parser: parser,
        }
    }

    pub fn eval_tree(&mut self) -> String {
        ast::eval_tree(self.parser.parse())
    }
}

#[test]
fn it_sums() {
    let text = "5+1";
    let tokenizer = token::Tokenizer::new(String::from(text));
    let parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new(parser);

    assert_eq!("6", interpreter.eval_tree());
}

#[test]
fn it_substract() {
    let text = "5-1";
    let tokenizer = token::Tokenizer::new(String::from(text));
    let parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new(parser);

    assert_eq!("4", interpreter.eval_tree());
}

#[test]
fn it_multiplies() {
    let text = "5*2";
    let tokenizer = token::Tokenizer::new(String::from(text));
    let parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new(parser);

    assert_eq!("10", interpreter.eval_tree());
}

#[test]
fn it_divide() {
    let text = "4/2";
    let tokenizer = token::Tokenizer::new(String::from(text));
    let parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new(parser);

    assert_eq!("2", interpreter.eval_tree());
}

#[test]
fn it_accepts_multiples_operation() {
    let text = "10+5-4-1";
    let tokenizer = token::Tokenizer::new(String::from(text));
    let parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new(parser);

    assert_eq!("10", interpreter.eval_tree());
}

#[test]
fn it_respect_precedence() {
    let text = "1+1*2";
    let tokenizer = token::Tokenizer::new(String::from(text));
    let parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new(parser);

    assert_eq!("3", interpreter.eval_tree());
}

#[test]
fn it_respects_grouped_expression() {
    let text = "4+(1+(1+1)*2)+1";
    let tokenizer = token::Tokenizer::new(String::from(text));
    let parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new(parser);

    assert_eq!("10", interpreter.eval_tree());
}

#[test]
fn it_accept_unary_operations() {
    let text = "(4+-1)--2";
    let tokenizer = token::Tokenizer::new(String::from(text));
    let parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new(parser);

    assert_eq!("5", interpreter.eval_tree());
}
