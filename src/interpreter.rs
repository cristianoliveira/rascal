use token::{Token, Kind, Tokenizer};
use ast::Node;
use parser::Parser;
use std::collections::HashMap;

// # Interpreter
//
// Represents the interpreter that is responsible for interpret 
// the Abstracted Sintax Tree generated by the Parser

pub struct Interpreter {
    pub symbol_table: HashMap<String, String>,
    pub imutable_table: HashMap<String, String>
}
impl Interpreter {
    pub fn new() -> Self {
        Interpreter {
            symbol_table: HashMap::new(),
            imutable_table: HashMap::new()
        }
    }
    // eval_tree
    //
    // It visits each node evaluating the binary operations returning the
    // result as String
    //
    // Example:
    //   The expression 3 * 5 + 5 will produce the follow tree and the result 20.
    //   It evaluates the left side first and applies a post-order calc
    //
    //         +-+
    //         |-|
    //     +---------+
    //     |         |
    //     v         v
    //    +-+       +-+
    //    |*|       |5|
    //  +-----+     +-+
    //  |     |
    //  v     v
    // ---   ---
    // |3|   |5|
    // +-+   +-+
    pub fn eval_tree(&mut self, tree: Node) -> String {
        let Node{ token, statements, conditional, left, right } = tree;
        match (*left, *right, *conditional) {

            (Some(lnode), Some(rnode), conditional) => match token.kind {
                Kind::Operator =>
                    binary_operation(self.eval_tree(lnode),
                                     &token.value,
                                     self.eval_tree(rnode)),

                Kind::Comparison =>
                    binary_comparison(self.eval_tree(lnode),
                                      &token.value,
                                      self.eval_tree(rnode)),

                Kind::Assign => {
                    let value = self.eval_tree(rnode);
                    let Token{ kind, value: name } = lnode.token;

                    if kind == Kind::CONST_ID {
                        self.imutable_table.insert(name, value.clone());
                    } else {
                        self.symbol_table.insert(name, value.clone());
                    }
                    value
                },

                Kind::ReAssign => {
                    let value = self.eval_tree(rnode);
                    let Token{ value: name, ..} = lnode.token;

                    if self.imutable_table.contains_key(&*name) {
                        panic!("Value error: invalid assign imutable {}", name)
                    }

                    self.symbol_table.insert(name, value.clone());
                    value
                },

                Kind::Conditional=> {
                    let condition = self.eval_tree(conditional.unwrap());

                    if truthy(condition) {
                        self.eval_tree(lnode)
                    } else {
                        self.eval_tree(rnode)
                    }
                }

                _ => String::from("nil")
            },

            (Some(lnode), None, _) => self.eval_tree(lnode),

            (None, Some(rnode), _) => match token.kind {
                Kind::Operator =>
                    unary_operation(token.value, self.eval_tree(rnode)),

                Kind::Return => self.eval_tree(rnode),

                _ => String::from("nil")
            },

            (None, None, conditional) => match token.kind {
                Kind::Statement => {
                    if let Some(list) = statements {
                        return list.iter()
                            .map(|n| self.eval_tree(n.clone()))
                            .fold(String::new(), |_, s|{
                                s
                            })
                    } else {
                        String::from("nil")
                    }
                },

                Kind::Conditional => {
                    let mut condition = self.eval_tree(conditional.clone().unwrap());

                    while truthy(condition) {
                        let _ = statements.clone()
                            .unwrap()
                            .iter()
                            .map(|n| self.eval_tree(n.clone()))
                            .fold(String::new(), |_, s|{
                                s
                            });
                        condition = self.eval_tree(conditional.clone().unwrap());
                    }

                    return String::from("nil")
                },

                Kind::ID =>
                    match self.imutable_table.get(&token.value) {
                        Some(value) => return value.clone(),
                        None =>
                            match self.symbol_table.get(&token.value) {
                                Some(value) => return value.clone(),
                                None =>
                                panic!("Interpreter error: undeclared variable")
                        }
                    },

                Kind::Empty => String::from("nil"),

                _ => token.value
            }
        }
    }
}

// unary_operation
// Resolves the unary operations Example: --1 == 1, 1++-1==0
fn unary_operation(operator: String, operand: String) -> String {
    let ioperand = if let Ok(val) = operand.parse::<i32>() { val } else {
        panic!("Sintax error: invalid unary operand {}", operand)
    };
    let result = match operator.as_ref() {
        "+" => ioperand,
        "-" => -(ioperand),
        _ => panic!("Sintax error: invalid unary operator {}", operator)
    };

    result.to_string()
}

// binary_operation
// Resolve binary expression for the given left, operator and right operand
fn binary_operation(left: String, operator: &String, right: String) -> String {
    let operleft = if let Ok(val) = left.parse::<i32>() { val } else {
        panic!("Sintax error: invalid operand: {}", left)
    };
    let operright = if let Ok(val) = right.parse::<i32>() { val } else {
        panic!("Sintax error: invalid operand: {}", right)
    };
    let result = match operator.as_ref() {
        "+" => operleft + operright,
        "-" => operleft - operright,
        "*" => operleft * operright,
        "/" => operleft / operright,
        _ => panic!("Sintax error: invalid operator {}", operator)
    };

    result.to_string()
}

// binary_operation
// Resolve binary expression for the given left, operator and right operand
fn binary_comparison(left: String, operator: &String, right: String) -> String {
    let bleft = left.replace("true","1").replace("false","0");
    let bright = right.replace("true","1").replace("false","0");

    let operleft = if let Ok(val) = bleft.parse::<i32>() { val } else {
        panic!("Sintax error: invalid operand: {}", left)
    };
    let operright = if let Ok(val) = bright.parse::<i32>() { val } else {
        panic!("Sintax error: invalid operand: {}", right)
    };

    let result = match operator.as_ref() {
        "==" => operleft == operright,
        "!=" => operleft != operright,
        "<" => operleft < operright,
        ">" => operleft > operright,
        "or"|"||" => operleft == 1 || operright == 1,
        "and"|"&&" => operleft == 1 && operright == 1,
        _ => panic!("Sintax error: invalid operator {}", operator)
    };

    result.to_string()
}

fn truthy(condition: String) -> bool {
    binary_comparison(condition,
                      &String::from("=="),
                      String::from("true")) == "true"
}

#[test]
fn it_eval_tree_leaf() {
    let token = Token::build(Kind::Integer, String::from("10"));
    let leaf = Node::leaf(token);

    assert_eq!("10", Interpreter::new().eval_tree(leaf))
}

#[test]
fn it_eval_the_node_binary_operation() {
    // 3+5
    let left = Node::leaf(Token::build(Kind::Integer, String::from("3")));
    let operator = Token::build(Kind::Operator, String::from("+"));
    let right = Node::leaf(Token::build(Kind::Integer, String::from("5")));
    let node = Node::binary(left, operator, right);

    assert_eq!("8", Interpreter::new().eval_tree(node))
}

#[test]
fn it_eval_complex_tree() {
    // 5+5*3
    let left = Node::leaf(Token::build(Kind::Integer, String::from("3")));
    let operator = Token::build(Kind::Operator, String::from("*"));
    let right = Node::leaf(Token::build(Kind::Integer, String::from("5")));
    let plusnode = Node::binary(left, operator, right);

    let operator = Token::build(Kind::Operator, String::from("+"));
    let sumright = Node::leaf(Token::build(Kind::Integer, String::from("5")));
    let sumnode = Node::binary(plusnode, operator, sumright);

    assert_eq!("20", Interpreter::new().eval_tree(sumnode))
}

#[test]
fn it_eval_unary_operations() {
    // 2 -- 2
    let rnode = Node::leaf(Token::build(Kind::Integer, String::from("2")));
    let negative_op = Token::build(Kind::Operator, String::from("-"));
    let unarynode = Node::unary(negative_op, rnode);

    let operator = Token::build(Kind::Operator, String::from("-"));
    let left = Node::leaf(Token::build(Kind::Integer, String::from("2")));
    let sumnode = Node::binary(left, operator, unarynode);

    assert_eq!("4", Interpreter::new().eval_tree(sumnode))
}

#[test]
fn it_sums() {
    let text = "5+1";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("6", Interpreter::new().eval_tree(parser.parse()));
}

#[test]
fn it_substract() {
    let text = "5-1";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("4", Interpreter::new().eval_tree(parser.parse()));
}

#[test]
fn it_multiplies() {
    let text = "5*2";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("10", Interpreter::new().eval_tree(parser.parse()));
}

#[test]
fn it_divide() {
    let text = "4/2";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("2", Interpreter::new().eval_tree(parser.parse()));
}

#[test]
fn it_accepts_multiples_operation() {
    let text = "10+5-4-1";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("10", Interpreter::new().eval_tree(parser.parse()));
}

#[test]
fn it_respect_precedence() {
    let text = "1+1*2";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("3", Interpreter::new().eval_tree(parser.parse()));
}

#[test]
fn it_respects_grouped_expression() {
    let text = "4+(1+(1+1)*2)+1";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("10", Interpreter::new().eval_tree(parser.parse()));
}

#[test]
fn it_accept_unary_operations() {
    let text = "(4+-1)--2";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("5", Interpreter::new().eval_tree(parser.parse()));
}

#[test]
fn it_accept_binary_comparison() {
    let text = "4 == 2";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("false", Interpreter::new().eval_tree(parser.parse()));
}

#[test]
fn it_accept_composed_binary_comparison() {
    let text = "1 > 1 or 2 == 2 and 3 != 3";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);

    assert_eq!("false", Interpreter::new().eval_tree(parser.parse()));
}


#[test]
fn it_eval_block_assigning_vars_to_symbol_table() {
    let text = "begin mut x = 10 end";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new();
    let _ = interpreter.eval_tree(parser.parse());

    assert_eq!("10", interpreter.symbol_table["x"]);
}

#[test]
fn it_eval_block_retrieve_vars_from_symbol_table() {
    let text = "begin imut x = 10; mut y = x + 5 end";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new();
    let _ = interpreter.eval_tree(parser.parse());

    assert_eq!("10", interpreter.imutable_table["x"]);
    assert_eq!("15", interpreter.symbol_table["y"]);
}

#[test]
fn it_eval_block_retrieve_eturn_statement() {
    let text = "begin mut x = 10; mut y = x + 5; return y + 5 end";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new();
    let result = interpreter.eval_tree(parser.parse());

    assert_eq!("20", result);
}

#[test]
fn it_eval_block_bolean_block() {
    let text = "begin mut x = 1; y = 2; return y == x end";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new();
    let result = interpreter.eval_tree(parser.parse());

    assert_eq!("false", result);
}

#[test]
fn it_eval_while_blocks() {
    let text = "begin mut y = 0; while y < 4 begin y = y + 1 end; return y == 4 end";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new();
    let result = interpreter.eval_tree(parser.parse());

    assert_eq!("true", result);
}

#[test]
fn it_eval_if_blocks() {
    let text = "begin mut y = 0; if y < 4 begin y = 4 end; return y == 4 end";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new();
    let result = interpreter.eval_tree(parser.parse());

    assert_eq!("true", result);
}

#[test]
#[should_panic]
fn it_validate_immutable() {
    let text = "begin imut y = 0; y = 1; return y end";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new();
    let result = interpreter.eval_tree(parser.parse());

    assert_eq!("42", result);
}

#[test]
fn it_accepts_mutable() {
    let text = "begin mut y = 0; y = 1; return y end";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new();
    let result = interpreter.eval_tree(parser.parse());

    assert_eq!("1", result);
}

#[test]
fn it_eval_ifelse_blocks() {
    let text = "begin mut y = 0; if false begin y = 4 else y = 42 end; return y end";
    let tokenizer = Tokenizer::new(String::from(text));
    let mut parser = Parser::new(tokenizer);
    let mut interpreter = Interpreter::new();
    let result = interpreter.eval_tree(parser.parse());

    assert_eq!("42", result);
}
