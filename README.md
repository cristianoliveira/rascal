# Rascal
A functional interpreted language made by Rust

## Features of functional languages
According with [Haskel wiki](https://wiki.haskell.org/Functional_programming) the features of a functional language are:

 - [x] Functions
 - [x] Higher-order functions
 - [ ] Purity
 - [x] Immutable data
 - [ ] Referential transparency
 - [ ] Lazy evaluation
 - [x] Recursion

# Use
```bash
rascal ./example.rl
```

# Install and run
```bash
git clone https://github.com/cristianoliveira/rascal.git
cd rascal
cargo build && cargo install
rascal ./example.rl
```

# Motivation?
> “If you don’t know how compilers work, then you don’t know how computers work.
> If you’re not 100% sure whether you know how compilers work,
> then you don’t know how they work.” — Steve Yegge

# Structure
  * Integers: `0-9`
  * Boolean: `true`, `false`
  * Imutables by default: `let x = 1;`
  * Mutables explicit: `let mut x = 1;`
  * Assign values: `x = 0;`
  * Blocks: `begin .. end`
  * Operator: `+`, `-`, `*`, `/` and `%`
  * Comparison: `==`,`!=`, `>`, `<`, `and` and `or`
  * If else: `if 1==1 begin .. else .. end`
  * Loop: `while 1==1 begin .. end`
  * Function: `fn foo = [x] { x + 1 }`
  * Print: `print (1+1)`

Each statement requires a `;` unless the last statement. Example of runnable code:
### Integers expressions
```ruby
begin
  let x = 20;
  let y = 15;
  let z = x + y;
  z - 5
end
```
Result: 30

### Bolean expressions
```ruby
begin
  let x = 2;
  let y = 1;
  let z = x != y;
  z == true
end
```
Result: true

### If Else blocks
```ruby
begin
  let x = 2;
  let mut y = 0;

  if x != 2 {
    y = 13
  else
    y = 42
  };

  y == 42
end
```
Result: true

### Loops
```ruby
begin
  let mut y = 0;

  while y < 4 {
    y = y + 1
  };

  y == 4
end
```
Result: true

### Scope per block
```ruby
begin
  let mut y = 0;

  {
    let mut x = y + 1
  };

  x == 4
end
```
Error: Variable x doesn't exists in this context

### Functions
```ruby
begin
  fn foo = [x] { x + 1 };
  
  foo(10)
end
```
Result: 11

### High Order Functions
```ruby
begin
  fn composed = [f] { f(10) };
  fn foo = [x] { x + 1 };
  
  composed(foo)
end
```
Result: 11

## Future implementations
  * Strings: support for strings
  * String comparison: support for compare strings
  * Print: prints on stdout the given expression
  * Return: return in the middle of a block
  * Stable REPL: run code without exiting for sintax errors
  * Comments: ignore after `#`
  * Lambda: support for short `x = |y| y + 1;`

## The Architecture
It is a simple interpreded language that walks on an AST executing the program.
I would like to implement some bytecode, just for science sake, but for now this
is fine. Example of an AST generated by code:

```ruby
begin
  let mut a = 10;
  let mut b = 1;

  while b != 0 {
    if a > b {
      a = a - b;

    else
      b = b - a;
    }
  }

  return a
end
```
![sintax](http://i.stack.imgur.com/JDAbW.png)

## Licence
MIT
